#! /usr/bin/env bqn
âŸ¨ToNats,SplitâŸ©â†â€¢Import "../bqn-libs/strings.bqn"
inâ†â€¢FLines "10.in"

ParseLineâ†{
  lineâ†' 'âŠ¸Split ğ•©
  dâ†'#'=Â¯1â†“1â†“âŠ‘line
  nâ†â‰ d
  sâ†>(nâ†‘/â¼)Â¨ToNatsÂ¨1â†“Â¯1â†“line
  vâ†ToNats âŠ‘âŒ½line
  dâ€¿sâ€¿v
}

mâ†ParseLineÂ¨ in

Fewestâ†{ğ•Š tgtâ€¿bsâ€¿Â·:
  stâ†â‹ˆ0â¥ŠËœâ‰ tgt
  tâ†0
  Stepâ†{t+â†©1â‹„<Ë˜â·âˆ¾â‰Â¨ğ•© â‰ âš‡1â€¿1 â‰bs}
  Step â€¢_while_(âˆ§Â´tgtâŠ¸â‰¢âš‡âˆâ€¿1) st
  t
}

â€¢Show +Â´FewestÂ¨m # Part 1

Costsâ†{ğ•Š s:
  combsâ†(â¥Š(â†•2Ë˜)/Â¨<) â†•â‰ s # all combinations of single presses
  combs â‰ Â¨âŠ¸(â‹âŠ¸âŠ)â†©       # sorted into ascending order of number of presses
  resâ†(+ËâŠâŸœs)Â¨combs     # what button press results in
  resâ†©res/Ëœmâ†âˆŠres       # take unique results
  cstâ†m/â‰ Â¨combs         # and their costs
  resâ‹ˆcst
}

Part2â†{ğ•Š Â·â€¿sâ€¿goal:
  memoâ†â€¢HashMapËœâŸ¨âŸ©
  pâ€¿pcostâ†Costs s
  {âˆ§Â´0=ğ•© ? 0;
  memo.Has ğ•© ? memo.Get ğ•© ;
  ğ•Š g:
  t1â†pâˆ§Â´âˆ˜â‰¤âš‡1â€¿âˆ g # which patterns still fit
  t2â†p â‰¡âš‡1â€¿âˆâ—‹(2âŠ¸|)g # which patterns would result in same parity
  mâ†t1âˆ§t2 # mask of above tests
  psâ†m/p # which patterns to test
  pcostsâ†m/pcost # and associated costs
  aâ†âŒŠÂ´âˆâˆ¾pcosts+2Ã—ğ•ŠÂ¨{2Ã·Ëœg-ğ•©}Â¨ps
  ğ•© memo.Set a
  a
  } goal
}

â€¢Show +Â´ Part2Â¨ m # Part 2
